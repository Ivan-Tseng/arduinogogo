<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 BLE æ§åˆ¶èˆ‡ EMG ç›£æ¸¬</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>ESP32 BLE é¦¬é”æ§åˆ¶èˆ‡ EMG æ•¸æ“š</h1>
    <button onclick="connectBLE()">ğŸ”— é€£æ¥ ESP32</button>
    <button onclick="sendCommand('forward')">ğŸš€ å‰é€²</button>
    <button onclick="sendCommand('backward')">ğŸ”„ å¾Œé€€</button>
    <button onclick="sendReset()">ğŸ”„ é‡æ–°é–‹å§‹ EMG</button>
    <button onclick="downloadCSV()">ğŸ’¾ ä¸‹è¼‰æ•¸æ“š</button>
    <p id="status">æœªé€£æ¥</p>
    
    <canvas id="emgChart" width="400" height="200"></canvas>
    
    <script>
        let bleDevice;
        let motorCharacteristic;
        let resetCharacteristic;
        let emgCharacteristic;
        let emgData = [];
        let labels = [];
        let chart;
        let isConnected = false;

        async function connectBLE() {
            try {
                if (isConnected) {
                    console.log("å·²é€£æ¥ ESP32");
                    return;
                }

                bleDevice = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: ['4fafc201-1fb5-459e-8fcc-c5c9c331914b']
                });

                const server = await bleDevice.gatt.connect();
                isConnected = true;
                const service = await server.getPrimaryService('4fafc201-1fb5-459e-8fcc-c5c9c331914b');
                motorCharacteristic = await service.getCharacteristic('c0de1234-5678-9101-1121-314151617181');
                resetCharacteristic = await service.getCharacteristic('d1e2f3a4-5678-9101-1121-314151617182');
                emgCharacteristic = await service.getCharacteristic('beb5483e-36e1-4688-b7f5-ea07361b26a8');

                // ç›£è½ EMG æ•¸æ“š
                emgCharacteristic.startNotifications();
                emgCharacteristic.addEventListener('characteristicvaluechanged', handleEMGData);

                document.getElementById("status").innerText = "âœ… å·²é€£æ¥";
                setupChart();

                // BLE æ–·é–‹æ™‚è‡ªå‹•é‡é€£
                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
            } catch (error) {
                console.error(error);
                document.getElementById("status").innerText = "âŒ é€£æ¥å¤±æ•—";
                isConnected = false;
            }
        }

        function onDisconnected() {
            console.log("BLE æ–·é–‹ï¼Œå˜—è©¦é‡æ–°é€£æ¥...");
            isConnected = false;
            document.getElementById("status").innerText = "ğŸ”´ é€£ç·šä¸­æ–·";
            setTimeout(connectBLE, 3000); // 3ç§’å¾Œè‡ªå‹•é‡é€£
        }

        async function sendCommand(command) {
            if (motorCharacteristic) {
                let encoder = new TextEncoder();
                await motorCharacteristic.writeValue(encoder.encode(command));
                console.log(`Sent: ${command}`);

                // ç­‰å¾…é¦¬é”æŒ‡ä»¤åŸ·è¡Œå¾Œï¼Œç¢ºä¿ EMG æ•¸æ“šç¹¼çºŒå‚³è¼¸
                setTimeout(() => {
                    if (emgCharacteristic) {
                        emgCharacteristic.startNotifications();
                        console.log("ğŸ”„ é‡æ–°é–‹å§‹ EMG æ•¸æ“šæ¥æ”¶");
                    }
                }, 1500);
            }
        }
        
        async function sendReset() {
            if (resetCharacteristic) {
                let encoder = new TextEncoder();
                await resetCharacteristic.writeValue(encoder.encode("reset"));
                console.log("EMG é‡æ–°é–‹å§‹");
                
                // æ¸…é™¤æ•¸æ“šä¸¦æ›´æ–°åœ–è¡¨
                emgData = [];
                labels = [];
                chart.update();
            }
        }

        function handleEMGData(event) {
            let value = new TextDecoder().decode(event.target.value);
            let emgValue = parseInt(value);
            if (!isNaN(emgValue)) {
                if (emgData.length > 50) {
                    emgData.shift();
                    labels.shift();
                }
                emgData.push(emgValue);
                labels.push(new Date().toLocaleTimeString());

                // åªåœ¨ä¸€å®šé–“éš”å…§æ›´æ–°åœ–è¡¨ï¼Œé¿å…éåº¦æ¸²æŸ“
                if (emgData.length % 5 === 0) {
                    chart.update();
                }
            }
        }

        function setupChart() {
            let ctx = document.getElementById('emgChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'EMG æ•¸æ“š',
                        data: emgData,
                        borderColor: 'blue',
                        borderWidth: 1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { display: true },
                        y: { display: true }
                    }
                }
            });
        }

        function downloadCSV() {
            let csvContent = "data:text/csv;charset=utf-8,Time,EMG Value\n";
            for (let i = 0; i < emgData.length; i++) {
                csvContent += labels[i] + "," + emgData[i] + "\n";
            }
            let encodedUri = encodeURI(csvContent);
            let link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "emg_data.csv");
            document.body.appendChild(link);
            link.click();
        }
    </script>
</body>
</html>
